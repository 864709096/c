# c
**************************************************

Difference between i++ and ++i

++i will increment the value of i, and then return the incremented value.

 i = 1;
 j = ++i;
 (i is 2, j is 2)
 
i++ will increment the value of i, but return the original value that i held before being incremented.

 i = 1;
 j = i++;
 (i is 2, j is 1)







**************************************************

区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上#即可输出前缀，例
如 %#x、%#o、%#lX、%#ho 等


**************************************************

当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为 0：  对于 short、int、long，就是整数 0；  对于 char，就是字符 '\0'；  对于 float、double，就是小数 0.0。


**************************************************

需要注意的是，逐个字符地给数组赋值并不会自动添加'\0'，例如：
char str[] = {'a', 'b', 'c'};
数组 str 的长度为 3，而不是 4，因为最后没有'\0'。
当用字符数组存储字符串时，要特别注意'\0'，要为'\0'留个位置；这意味着，字符数组的长度至少要比字符串的长
度大 1。请看下面的例子：
char str[7] = "abc123";
"abc123"看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的'\0'。如果将 str 的
长度定义为 6，它就无法容纳'\0'了。

**************************************************

在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机
的、无意义的，而不是我们通常认为的“零”值。这一点非常重要，大家一定要谨记，否则后面会遇到很多奇葩的






**************************************************

将数组的所有元素都初始化为“零”值
char str[30] = { 0 }; //将所有元素都初始化为 0，或者说 '\0'
错误。



**************************************************

注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表
达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&

通过结构体指针可以获取结构体成员，一般形式为：
(*pointer).memberName
或者：
pointer->memberName


int len = sizeof(stus) / sizeof(struct stu);

结构体指针作为函数参数
结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编
译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运
行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。

**************************************************

还应该注意，结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不
会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，
才需要内存来存储。



**************************************************

case 关键字后面必须是一个整数，或者是结果为整数的表达式，
但不能包含任何变量，正是由于 Mon、Tues、Wed 这些名字最终会被替换成一个整数，所以它们才能放在 case 后
面。



**************************************************

共同体Union
共用体也是一种自定义类型
结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用
同一段内存，修改一个成员会影响其余所有成员。
结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长
的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把
原来成员的值覆盖掉。

union data a;
printf("%d, %d\n", sizeof(a), sizeof(union data) );


包含共用体的结构体

struct{
char name[20];
int num;
char sex;
char profession;
union{
    float score;
    char course[20];
     } sc;
} bodys[TOTAL];



**************************************************

有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电
两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C 语言又提供了一种叫做位域的数据
结构

在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。

struct bs{
unsigned m;
unsigned n: 4;
unsigned char ch: 6;
};



**************************************************

C 语言中不能直接使用二进制，&两边的操作数可以是十进制、八进制、十六进制，它们在内存中最终都是以二进
制形式存储


数据在内存中的存储

整数在内存中都是以补码的形式存放的
正数：正数的原码、反码、补码都相同。
负数：
原码 符号位是1，其余位和绝对值对应的正数相同。
反码 除符号位以外按位取反。
补码 反码加1。（所以负数在内存中的存储是对应的正数按位取反然后加1）


(32位操作系统)
5
原码  0000 0000 0000 0000 0000 0000 0000 0101
反码  0000 0000 0000 0000 0000 0000 0000 0101
补码  0000 0000 0000 0000 0000 0000 0000 0101

-5
原码  1000 0000 0000 0000 0000 0000 0000 0101
反码  1111 1111 1111 1111 1111 1111 1111 1010
补码  1111 1111 1111 1111 1111 1111 1111 1011
十六进制为
FFFFFFFB
